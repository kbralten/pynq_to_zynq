# **Loopback Project Step 5: Advanced Workflows**

## **1\. The Goal**

To evolve our prototype into a professional-grade embedded system. We will learn to:

1. **Hot-Swap Hardware:** Update the FPGA logic on a running system without rebooting.  
2. **Bake Applications:** Integrate our C code into the SD card image as a system utility.  
3. **Enable Self-Hosting:** Install gcc and build tools *on the board* for rapid on-device iteration.

## **2\. Sanity Check**

* **Step 4 Complete:** You have a working PetaLinux build and have verified the loopback\_test application works manually.  
* **PetaLinux Tools:** Source the settings script (source /tools/Xilinx/PetaLinux/2025.1/settings.sh).

## **3\. Topic A: Dynamic Hardware Updates (The Hot-Swap)**

Imagine you found a bug in your Verilog (or you just want to change the adder to \+5). You do **not** need to rebuild the whole OS or reboot the board to test this.

### **Step 1: Modify & Regenerate**

1. **Vivado:** Open your IP Source (math\_accelerator\_v1\_0\_S00\_AXI.v).  
2. **Edit:** Change the logic from \+ 32'd1 to \+ 32'd5.  
3. **Repackage:** Re-package the IP (as done in Step 1).  
4. **Bitstream:** In the main project, click **Generate Bitstream**.  
   * *Result:* You get a new system\_design\_wrapper.bit.

### **Step 2: Convert Bitstream to Binary**

Linux cannot load a .bit file directly because it contains a text header. We must strip it using the Xilinx bootgen tool (available in your shell after sourcing settings).

1. Locate Bitstream:  
   Find your generated .bit file (usually in \<vivado\_project\>/\<project\>.runs/impl\_1/).  
2. Create BIF File:  
   Create a text file named bitstream.bif with this content:  
   ```
   all:  
   {  
       system_design_wrapper.bit  
   }
   ```

3. **Run Bootgen:**  
   ```bash
   bootgen -image bitstream.bif -arch zynq -process_bitstream bin
   ```

   * *Result:* You now have `system_design_wrapper.bit.bin`.

### **Step 3: Hot-Swap**

1. **Transfer:** SCP the .bin file to the board.  
   ```bash
   scp system_design_wrapper.bit.bin petalinux@<BOARD_IP>:/home/petalinux/
   ```

2. **Load:** On the board, use the Xilinx FPGA Utility.  
   ```bash
   sudo fpgautil -b system_design_wrapper.bit.bin
   ```

   * *Note:* You might see a warning about "Timeouts" or "Flags". Usually, it succeeds.  
3. **Verify:** Run your loopback\_test app.  
   * *Success:* It should now report Read 47 (if input was 42 and logic is \+5).

## **4\. Topic B: Baking the App (Yocto Recipes)**

Copying the C binary manually is tedious. Let's make PetaLinux compile and install it automatically every time we build the OS.

### **Step 1: Create the App Recipe**

In your PetaLinux project folder:
```bash
petalinux-create -t apps --name loopback-test --enable
```

* This creates a folder structure at project-spec/meta-user/recipes-apps/loopback-test/.

### **Step 2: Update Source Code**

1. Navigate to `project-spec/meta-user/recipes-apps/loopback-test/files/`.  
2. Delete the auto-generated `loopback-test.c`.  
3. Copy your working `loopback_test.c` (from Step 4) into this folder.  
4. Rename it to `loopback-test.c` (to match the Makefile generated by PetaLinux).

### **Step 3: Build & Deploy**

1. **Rebuild:**  
   ```bash
   petalinux-build
   ```

   * *Note:* This will be much faster than the first build because it only compiles your app and repackages the rootfs.  
2. **Package:**  
   ```bash
   petalinux-package --wic --bootfiles "BOOT.BIN image.ub boot.scr" --rootfs-file images/linux/rootfs.tar.gz
   ```

3. **Result:** When you boot this new image, you can simply type loopback-test at the prompt. It is installed in /usr/bin/ automatically.

## **5\. Topic C: On-Board GCC (Self-Hosting)**

For rapid testing, you might want to compile code directly on the Zynq, just like on a Raspberry Pi.

### **Step 1: Configure RootFS**

1. Open the configuration menu:  
   ```bash
   petalinux-config -c rootfs
   ```

2. Navigate to **Petalinux Package Groups**.  
3. Select **packagegroup-petalinux-self-hosted**.  
   * *What this does:* It selects gcc, make, binutils, glibc-dev, and other build tools.  
4. Exit and Save.

### **Step 2: Rebuild**

1. **Build:**  
   ```bash
   petalinux-build
   ```

   * *Warning:* Your rootfs size will grow significantly (by 100MB+). Ensure your SD card partitions are large enough.

2. **Package (WIC):**
   ```bash
   petalinux-package --wic --bootfiles "BOOT.BIN image.ub boot.scr" --rootfs-file images/linux/rootfs.tar.gz
   ```

3. **Flash:**
   Flash the new `petalinux-sdimage.wic` to your SD card (just like in Step 3).

### **Step 3: Verify**

1. Boot the new image.  
2. On the board, check the compiler:  
   ```bash
   gcc --version
   ```

3. **Workflow Upgrade:** You can now edit C files on the board using vi or nano and compile them immediately with gcc loopback\_test.c \-o test, skipping the cross-compilation step entirely.

## **6\. Recap**

You have moved beyond "getting it to work" to "working efficiently."

* **Hot-Swapping** lets you iterate on Hardware logic in seconds.  
* **Recipes** let you productize your Software so it survives reboots and distribution.  
* **Self-Hosting** gives you a powerful on-board dev environment for debugging.

You now possess the complete toolkit of a Zynq Full-Stack Developer.

## **7. Next Step**

We have a professional workflow, but a minimal OS. Let's upgrade to a full Desktop experience.

**[Go to Step 6: The Debian Hybrid](loopback_step6.md)**